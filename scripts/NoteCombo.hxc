import funkin.play.PlayState;
import funkin.modding.module.Module;
import funkin.Paths;
import funkin.graphics.FunkinSprite;
import funkin.Conductor;
import flixel.FlxG;
import funkin.Highscore;
import funkin.audio.FunkinSound;
import flixel.text.FlxText;
import flixel.math.FlxMath;
import flixel.group.FlxTypedGroup;
import funkin.save.Save;

class NoteCombo extends Module {
    var combo = 0;
    var hashitnote = false;
    var notehittime = 0;
    var holdnoteend = 0;
    var coolcombo:FunkinSprite;
    var holdnoteendtime = 0;
    var holdnotestart = 0;
    var comtostring = "";
    var comboGroup:FlxTypedGroup;

    var comboSwoosh:ComboSwoosh;

    function new (){
        super("Note Combo", 1, {state: PlayState});
        
        if (FlxG.save.data.cachestuff)
        {
            FlxG.sound.cache(Paths.sound("comboSound"));
            FunkinSprite.cacheSparrow("noteCombo");
            FunkinSprite.cacheSparrow("noteComboNumbers");
        }
    }


    override function onNoteHit(event)
    {
        super.onNoteHit(event);

        // if (PlayState.instance != null)
        // {
            if (event.note.noteData.getMustHitNote())
            {
                if (FlxG.save.data.comboswoosh)
                {
                    //notehittime is now calculated by using steps instead of ms
                    notehittime = event.note.noteData.getStepTime() + (Conductor.instance.get_bpm() / 16);
                    combo++;
                    hashitnote = true;
                    checkSustain();
                }

            }

        // }



    }
    override function onCountdownStart(event)
    {
        super.onCountdownStart(event);
        // PlayState.instance.add(comboSwoosh);
        initVariables();

    }

    override function onCountdownEnd(event)
    {
        super.onCountdownEnd(event);

        // Move the combo swoosh to the side on mobile
        // if (FlxG.width > 1280)
        // {
        //     coolcombo.setPosition(-235, 255);
        // }
        // else if (PlayState.instance.playerStrumline.x == (FlxG.width / 2 - PlayState.instance.playerStrumline.width / 2))
        // {
        //     coolcombo.setPosition(-235, 325);
        // }
        // else
        // {
        //     coolcombo.setPosition(30, 300);
        // }
    }

    override function onUpdate(event)
    {
        // if (PlayState.instance != null)
        // {
        if (FlxG.save.data.comboswoosh)
        {
            if (Highscore.tallies.combo == 0)
            {
                combo = 0;
            }
            else if (combo >= FlxG.save.data.swooshthreshold)
            {
                if (Conductor.instance.currentStep >= (notehittime + holdnoteend) && hashitnote)
                {
                    if (!PlayState.instance.isBotPlayMode)
                    {
                        comboSwoosh.playCombo(combo);
                        combo = 0;
                    }
                }
            }
           
        }
            
        // }
        super.onUpdate(event);
      
     
    }

    function initVariables()
    {
        // if (coolcombo != null)
        // {
        //     coolcombo.destroy();
        // }

        if (PlayState.instance.isBotPlayMode)
        {
            return;
        }
        hashitnote = false;
        holdnotestart = 0;
        holdnoteend = 0;
        holdnoteendtime = 0;
        combo = 0;
        notehittime = 0;
        comtostring = "";

        comboGroup = new FlxTypedGroup();
        comboGroup.cameras = [PlayState.instance.camHUD];

        PlayState.instance.add(comboGroup);

        if (FlxG.save.data.comboswoosh)
        {
            comboSwoosh = new ComboSwoosh(); //30,300


            switch (Save.instance.modOptions["ComboSwooshCamera"])
            {
                case "HUD":
                    comboSwoosh.camera = PlayState.instance.camHUD;
                    switch (Save.instance.modOptions["ComboSwooshPosition"])
                    {
                        case "Left":
                            comboSwoosh.setPosition(50 * comboSwoosh.comboScale,300);
                        case "Middle":
                            comboSwoosh.setPosition(400,300);
                        case "Right":
                            comboSwoosh.setPosition((FlxG.width - (comboSwoosh.coolCombo.width)) + (300 + comboSwoosh.coolComboOffset) - 50,300);
                            // comboSwoosh.x += 55 / (1 - comboSwoosh.comboScale);
                    }
                case "World":     
                    if (PlayState.instance.currentStage != null)
                    {
                        // Check if a girlfriend is available on the current stage, if it isn't go try using the opponent.
                        if (PlayState.instance.currentStage.getGirlfriend() != null)
                        {
                            comboSwoosh.camera = PlayState.instance.camGame;
                            comboSwoosh.setPosition(PlayState.instance.currentStage.getGirlfriend().x, PlayState.instance.currentStage.getGirlfriend().y + (PlayState.instance.currentStage.getGirlfriend().height / 2));//250
                        }
                        else
                        {
                            comboSwoosh.camera = PlayState.instance.camGame;
                            comboSwoosh.setPosition(PlayState.instance.currentStage.getDad().x, PlayState.instance.currentStage.getDad().y + (PlayState.instance.currentStage.getDad().height / 2));//250
                        }
                    }
                    else
                    {
                        // Force the Combo Swoosh to use the HUD Camera if a stage is not found.
                        comboSwoosh.camera = PlayState.instance.camHUD;
                    }  
            }
           

    
            
           
            PlayState.instance.add(comboSwoosh);
        }
    }

    function checkSustain()
    {
        //Rewrote the sutain note stuff
        if (event.note.noteData.getStepLength() > 0 && event.note.noteData.getMustHitNote())
        {
            holdnotestart = event.note.noteData.getStepTime();
            holdnoteend = FlxMath.roundDecimal(event.note.noteData.getStepLength());
            holdnoteendtime = Conductor.instance.currentStep + holdnoteend + 4;
        }
        else
        {
            holdnotestart = 0;
            holdnoteend = 0;
            holdnoteendtime = 0;
        }
    }
}
